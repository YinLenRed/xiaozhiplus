# 定时器管理查询条件说明

## 📋 **给Java后端人员的查询条件整理**

### 🎯 **概述**

相对时间定时器管理功能支持多种查询和操作方式，以下是详细的查询条件说明。

---

## 1. 📊 **查询定时器列表**

### 功能：`list_relative_timers`
### 触发词汇：
- "有哪些闹钟"
- "查看定时提醒" 
- "现在设置了什么提醒"
- "查看我的定时器"

### 查询条件：
| 条件 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `device_id` | **必须** | 设备唯一标识 | `"f0:9e:9e:04:8a:44"` |
| `status` | 固定 | 只查询活跃状态 | `"active"` |
| `target_time` | 过滤 | 大于当前时间的定时器 | `> datetime.now()` |

### 返回字段：
```json
{
  "timers": [
    {
      "timer_id": "设备ID_时间戳_序号",
      "content": "提醒内容",
      "action_type": "动作类型",
      "target_time": "2025-09-01T12:31:00",
      "duration_description": "30分钟",
      "remaining_time": "剩余时间对象"
    }
  ]
}
```

---

## 2. ❌ **删除定时器**

### 功能：`cancel_relative_timer`
### 触发词汇：
- "取消闹钟"
- "删除提醒"
- "取消定时器"
- "取消XX点的提醒"

### 查询条件：
| 条件 | 类型 | 必须 | 说明 | 示例 |
|------|------|------|------|------|
| `device_id` | string | ✅ | 设备唯一标识 | `"f0:9e:9e:04:8a:44"` |
| `confirm_action` | string | ✅ | 操作类型 | `"list"` / `"cancel"` |
| `target_time` | string | ❌ | 目标时间匹配 | `"12点"`, `"12:30"` |
| `content_keyword` | string | ❌ | 内容关键词匹配 | `"吃饭"`, `"开会"` |

### 匹配逻辑：
```python
# 时间匹配（模糊匹配）
if target_time and (target_time in timer_time_str or timer_time_str in target_time):
    # 例如：用户说"12点" 匹配 "12:30"

# 内容匹配（包含匹配）  
if content_keyword and content_keyword in timer["content"]:
    # 例如：用户说"吃饭" 匹配 "提醒我吃饭"
```

---

## 3. ✏️ **修改定时器**

### 功能：`modify_relative_timer`
### 触发词汇：
- "修改闹钟"
- "更改提醒时间"
- "修改定时器"
- "修改XX点的提醒"

### 查询条件：
| 条件 | 类型 | 必须 | 说明 | 示例 |
|------|------|------|------|------|
| `device_id` | string | ✅ | 设备唯一标识 | `"f0:9e:9e:04:8a:44"` |
| `confirm_action` | string | ✅ | 操作类型 | `"list"` / `"select"` / `"modify"` |
| `target_time` | string | ❌ | 要修改的定时器时间 | `"12点"`, `"12:30"` |
| `new_time` | string | ❌ | 新的定时时间 | `"30分钟后"`, `"1小时后"` |
| `content_keyword` | string | ❌ | 内容关键词匹配 | `"吃饭"`, `"开会"` |

### 操作流程：
```
1. confirm_action="list"    → 列出所有定时器供选择
2. confirm_action="select"  → 根据条件选择要修改的定时器
3. confirm_action="modify"  → 执行修改操作
```

---

## 4. 📊 **数据结构详情**

### 定时器注册表结构：
```python
timer_registry = {
    "timer_id": {
        "device_id": "f0:9e:9e:04:8a:44",
        "content": "吃饭",                    # 提醒内容
        "action_type": "叫我",               # 动作类型 
        "target_time": datetime,             # 目标时间
        "duration_description": "30分钟",    # 时间描述
        "timer_type": "relative",            # 定时器类型
        "created_time": datetime,            # 创建时间
        "status": "active"                   # 状态：active/cancelled/modified
    }
}
```

### 支持的定时器类型：
- `"relative"`: schedule_relative_timer创建的定时器
- `"temp_relative"`: save_user_strategy创建的临时定时器

---

## 5. 🔍 **查询条件优先级**

### 删除和修改功能的匹配优先级：
1. **时间匹配优先**：如果提供了`target_time`，优先按时间匹配
2. **内容匹配次之**：如果时间匹配失败，尝试内容关键词匹配
3. **精确优于模糊**：精确时间 > 模糊时间 > 内容关键词

### 示例匹配场景：
```python
# 场景1：精确时间匹配
用户: "取消12:30的提醒"
匹配: target_time="12:30" → 查找 target_time.strftime("%H:%M") == "12:30"

# 场景2：模糊时间匹配  
用户: "取消12点的提醒"
匹配: target_time="12点" → 查找 "12" in "12:30"

# 场景3：内容关键词匹配
用户: "删除吃饭提醒"
匹配: content_keyword="吃饭" → 查找 "吃饭" in "叫我吃饭"
```

---

## 6. 🎯 **多轮对话状态管理**

### confirm_action参数说明：

#### 查询功能：
- 无需多轮对话，直接返回结果

#### 删除功能：
- `"list"`: 用户只说"取消闹钟"，需要先显示列表
- `"cancel"`: 用户指定了具体要取消的定时器

#### 修改功能：
- `"list"`: 用户只说"修改闹钟"，需要先显示列表
- `"select"`: 用户指定了要修改的定时器，询问新时间  
- `"modify"`: 用户提供了新时间，执行修改

---

## 7. 💡 **实际使用示例**

### 完整的多轮对话流程：

```
# 场景：删除定时器
用户: "取消闹钟"
→ confirm_action="list"
→ 系统列出所有定时器

用户: "取消吃饭的"  
→ confirm_action="cancel", content_keyword="吃饭"
→ 系统执行删除操作

# 场景：修改定时器
用户: "修改闹钟"
→ confirm_action="list" 
→ 系统列出所有定时器

用户: "修改开会的"
→ confirm_action="select", content_keyword="开会"
→ 系统询问新时间

用户: "改成45分钟后"
→ confirm_action="modify", new_time="45分钟后"
→ 系统执行修改操作
```

---

## 8. ⚠️ **注意事项**

### 对Java后端的建议：
1. **设备隔离**：查询时必须按device_id过滤
2. **状态管理**：只处理status="active"的定时器
3. **时间过滤**：只显示target_time > 当前时间的定时器
4. **模糊匹配**：支持部分字符串匹配（如"12点"匹配"12:30"）
5. **优雅降级**：如果没有匹配的定时器，提供友好的提示

### 扩展建议：
- 可以考虑添加按创建时间排序
- 可以添加按定时器类型过滤
- 可以添加批量操作支持

---

## 🎉 **总结**

定时器管理功能支持完整的CRUD操作，提供了灵活的查询条件：

✅ **设备级隔离**：每个设备独立管理定时器  
✅ **多种匹配方式**：时间匹配 + 内容关键词匹配  
✅ **多轮对话支持**：智能确认和选择流程  
✅ **状态管理**：完整的定时器生命周期跟踪  

这套查询条件设计既满足了用户的自然语言交互需求，又提供了足够的灵活性支持各种使用场景。
