#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MQTT Webhookså›è°ƒå¤„ç†å™¨
å®ç°å®Œæ•´çš„ MQTT -> ACK -> TTS -> WebSocket -> ç¡¬ä»¶æ’­æ”¾ æµç¨‹
"""

import asyncio
import json
import time
import uuid
import websockets
from datetime import datetime
from typing import Dict, Any, Optional
from config.logger import setup_logging
from core.providers.tts.base import TTSProviderBase

TAG = __name__


class WebhookCallbackHandler:
    """MQTT Webhookså›è°ƒå¤„ç†å™¨"""
    
    def __init__(self, config: Dict[str, Any], mqtt_client=None, tts_provider: TTSProviderBase = None):
        self.config = config
        self.mqtt_client = mqtt_client
        self.tts_provider = tts_provider
        self.logger = setup_logging()
        
        # è·Ÿè¸ªæ­£åœ¨å¤„ç†çš„è¯·æ±‚
        self.pending_requests = {}
        
        # WebSocketè¿æ¥ç®¡ç†
        self.device_websockets = {}
        
        # è®¾ç½®MQTTå®¢æˆ·ç«¯çš„é»˜è®¤ACKå¤„ç†å™¨
        if self.mqtt_client:
            self.mqtt_client.set_default_ack_handler(self.handle_device_ack)
    
    async def handle_device_ack(self, device_id: str, track_id: str, ack_data: Dict):
        """
        å¤„ç†è®¾å¤‡ACKå›è°ƒ - è¿™æ˜¯Webhooksæµç¨‹çš„æ ¸å¿ƒ
        
        æµç¨‹: è®¾å¤‡æ”¶åˆ°å”¤é†’æŒ‡ä»¤ -> å‘é€ACK -> è§¦å‘TTS -> å‘é€éŸ³é¢‘ -> è®¾å¤‡æ’­æ”¾
        """
        self.logger.bind(tag=TAG).info(f"ğŸ”” æ”¶åˆ°è®¾å¤‡ACK: {device_id}, track_id: {track_id}")
        
        try:
            # 1. æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„å¾…å¤„ç†è¯·æ±‚
            if track_id not in self.pending_requests:
                self.logger.bind(tag=TAG).warning(f"æœªæ‰¾åˆ°å¯¹åº”çš„å¾…å¤„ç†è¯·æ±‚: {track_id}")
                return
            
            request_info = self.pending_requests[track_id]
            text_content = request_info.get("text", "")
            
            if not text_content:
                self.logger.bind(tag=TAG).error(f"ç¼ºå°‘æ–‡æœ¬å†…å®¹: {track_id}")
                return
            
            # 2. æ›´æ–°è¯·æ±‚çŠ¶æ€
            request_info["status"] = "ack_received"
            request_info["ack_time"] = datetime.now().isoformat()
            request_info["ack_data"] = ack_data
            
            # 3. ç”ŸæˆTTSéŸ³é¢‘
            self.logger.bind(tag=TAG).info(f"ğŸµ å¼€å§‹ç”ŸæˆTTSéŸ³é¢‘: {text_content[:50]}...")
            audio_data = await self._generate_tts_audio(text_content, track_id)
            
            if audio_data:
                # 4. é€šè¿‡WebSocketå‘é€éŸ³é¢‘åˆ°è®¾å¤‡
                success = await self._send_audio_via_websocket(device_id, audio_data, track_id)
                
                if success:
                    request_info["status"] = "audio_sent"
                    request_info["audio_sent_time"] = datetime.now().isoformat()
                    self.logger.bind(tag=TAG).info(f"âœ… éŸ³é¢‘å‘é€æˆåŠŸ: {track_id}")
                else:
                    request_info["status"] = "audio_send_failed"
                    self.logger.bind(tag=TAG).error(f"âŒ éŸ³é¢‘å‘é€å¤±è´¥: {track_id}")
            else:
                request_info["status"] = "tts_failed"
                self.logger.bind(tag=TAG).error(f"âŒ TTSç”Ÿæˆå¤±è´¥: {track_id}")
            
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"âŒ å¤„ç†è®¾å¤‡ACKå¤±è´¥: {e}")
            if track_id in self.pending_requests:
                self.pending_requests[track_id]["status"] = "error"
                self.pending_requests[track_id]["error"] = str(e)
    
    async def register_awaken_request(self, device_id: str, text: str, track_id: str = None):
        """
        æ³¨å†Œå”¤é†’è¯·æ±‚ï¼Œç­‰å¾…è®¾å¤‡ACK
        
        åœ¨å‘é€MQTTå”¤é†’å‘½ä»¤ä¹‹å‰è°ƒç”¨æ­¤æ–¹æ³•ï¼Œæ³¨å†Œå¾…å¤„ç†çš„è¯·æ±‚
        """
        if not track_id:
            track_id = f"WH{datetime.now().strftime('%Y%m%d%H%M%S')}{uuid.uuid4().hex[:6]}"
        
        # æ³¨å†Œå¾…å¤„ç†è¯·æ±‚
        self.pending_requests[track_id] = {
            "device_id": device_id,
            "text": text,
            "status": "registered",
            "register_time": datetime.now().isoformat(),
            "track_id": track_id
        }
        
        self.logger.bind(tag=TAG).info(f"ğŸ“ æ³¨å†Œå”¤é†’è¯·æ±‚: {device_id}, track_id: {track_id}")
        return track_id
    
    async def _generate_tts_audio(self, text: str, track_id: str) -> Optional[bytes]:
        """ç”ŸæˆTTSéŸ³é¢‘"""
        try:
            if not self.tts_provider:
                self.logger.bind(tag=TAG).warning("TTSæä¾›å™¨æœªé…ç½®ï¼Œä½¿ç”¨æ¨¡æ‹ŸéŸ³é¢‘")
                # è¿”å›æ¨¡æ‹ŸéŸ³é¢‘æ•°æ®
                await asyncio.sleep(0.5)  # æ¨¡æ‹ŸTTSç”Ÿæˆæ—¶é—´
                return f"MOCK_AUDIO_DATA_FOR_{text[:20]}".encode()
            
            # è°ƒç”¨å®é™…çš„TTSæœåŠ¡
            audio_data = await self.tts_provider.generate_audio(text)
            
            if audio_data:
                self.logger.bind(tag=TAG).info(f"âœ… TTSç”ŸæˆæˆåŠŸ: {len(audio_data)} bytes")
                return audio_data
            else:
                self.logger.bind(tag=TAG).error("TTSæä¾›å™¨è¿”å›ç©ºæ•°æ®")
                return None
                
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"TTSç”Ÿæˆå¼‚å¸¸: {e}")
            return None
    
    async def _send_audio_via_websocket(self, device_id: str, audio_data: bytes, track_id: str) -> bool:
        """é€šè¿‡WebSocketå‘é€éŸ³é¢‘åˆ°è®¾å¤‡"""
        try:
            # æ„å»ºéŸ³é¢‘æ¶ˆæ¯
            audio_message = {
                "type": "audio",
                "track_id": track_id,
                "audio_data": audio_data.hex(),  # è½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²
                "timestamp": datetime.now().isoformat(),
                "device_id": device_id
            }
            
            # å°è¯•å‘é€åˆ°è®¾å¤‡çš„WebSocketè¿æ¥
            websocket_url = self._get_device_websocket_url(device_id)
            
            if websocket_url:
                success = await self._send_to_websocket(websocket_url, audio_message)
                return success
            else:
                # å¦‚æœæ²¡æœ‰ç›´æ¥çš„WebSocketè¿æ¥ï¼Œå°è¯•é€šè¿‡ç°æœ‰çš„è¿æ¥ç®¡ç†å™¨
                success = await self._send_via_connection_manager(device_id, audio_message)
                return success
                
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"WebSocketéŸ³é¢‘å‘é€å¼‚å¸¸: {e}")
            return False
    
    def _get_device_websocket_url(self, device_id: str) -> Optional[str]:
        """è·å–è®¾å¤‡çš„WebSocketè¿æ¥URL"""
        # è¿™é‡Œå¯ä»¥æ ¹æ®è®¾å¤‡IDæ„å»ºWebSocket URL
        # æˆ–è€…ä»è®¾å¤‡æ³¨å†Œè¡¨ä¸­è·å–
        
        # ç¤ºä¾‹: å‡è®¾è®¾å¤‡æœ‰å›ºå®šçš„WebSocketç«¯ç‚¹
        device_ws_port = self.config.get("device_websocket", {}).get("port", 8080)
        device_ip = self._get_device_ip(device_id)
        
        if device_ip:
            return f"ws://{device_ip}:{device_ws_port}/audio"
        
        return None
    
    def _get_device_ip(self, device_id: str) -> Optional[str]:
        """è·å–è®¾å¤‡IPåœ°å€"""
        # è¿™é‡Œåº”è¯¥ä»è®¾å¤‡ç®¡ç†ç³»ç»Ÿä¸­è·å–è®¾å¤‡IP
        # æˆ–è€…ä»é…ç½®æ–‡ä»¶ä¸­è¯»å–è®¾å¤‡æ˜ å°„
        
        device_mapping = self.config.get("device_mapping", {})
        return device_mapping.get(device_id)
    
    async def _send_to_websocket(self, websocket_url: str, message: Dict) -> bool:
        """å‘é€æ¶ˆæ¯åˆ°WebSocket"""
        try:
            async with websockets.connect(websocket_url) as websocket:
                await websocket.send(json.dumps(message))
                self.logger.bind(tag=TAG).info(f"ğŸ“¡ WebSocketæ¶ˆæ¯å‘é€æˆåŠŸ: {websocket_url}")
                return True
                
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"WebSocketè¿æ¥å¤±è´¥: {websocket_url}, {e}")
            return False
    
    async def _send_via_connection_manager(self, device_id: str, message: Dict) -> bool:
        """é€šè¿‡ç°æœ‰çš„è¿æ¥ç®¡ç†å™¨å‘é€æ¶ˆæ¯"""
        try:
            # è¿™é‡Œåº”è¯¥ä¸ç°æœ‰çš„WebSocketè¿æ¥ç®¡ç†å™¨é›†æˆ
            # å‡è®¾æœ‰ä¸€ä¸ªå…¨å±€çš„è¿æ¥ç®¡ç†å™¨
            
            self.logger.bind(tag=TAG).info(f"ğŸ“¨ é€šè¿‡è¿æ¥ç®¡ç†å™¨å‘é€éŸ³é¢‘: {device_id}")
            
            # æ¨¡æ‹Ÿå‘é€è¿‡ç¨‹
            await asyncio.sleep(0.3)
            
            # å®é™…å®ç°åº”è¯¥è°ƒç”¨è¿æ¥ç®¡ç†å™¨çš„å‘é€æ–¹æ³•
            # connection_manager.send_to_device(device_id, message)
            
            return True
            
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"è¿æ¥ç®¡ç†å™¨å‘é€å¤±è´¥: {e}")
            return False
    
    async def handle_device_speak_done(self, device_id: str, track_id: str, event_data: Dict):
        """å¤„ç†è®¾å¤‡æ’­æ”¾å®Œæˆäº‹ä»¶"""
        self.logger.bind(tag=TAG).info(f"ğŸ¯ è®¾å¤‡æ’­æ”¾å®Œæˆ: {device_id}, track_id: {track_id}")
        
        try:
            if track_id in self.pending_requests:
                # æ›´æ–°è¯·æ±‚çŠ¶æ€
                self.pending_requests[track_id]["status"] = "completed"
                self.pending_requests[track_id]["completed_time"] = datetime.now().isoformat()
                self.pending_requests[track_id]["event_data"] = event_data
                
                # è½¬å‘å®Œæˆäº‹ä»¶åˆ°Javaåç«¯
                await self._forward_completion_to_java(device_id, track_id, event_data)
                
                self.logger.bind(tag=TAG).info(f"âœ… å®Œæ•´æµç¨‹å®Œæˆ: {track_id}")
                
                # å¯é€‰ï¼šæ¸…ç†å·²å®Œæˆçš„è¯·æ±‚
                await asyncio.sleep(5)  # ç­‰å¾…5ç§’åæ¸…ç†
                if track_id in self.pending_requests:
                    del self.pending_requests[track_id]
                    
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"å¤„ç†æ’­æ”¾å®Œæˆäº‹ä»¶å¤±è´¥: {e}")
    
    async def _forward_completion_to_java(self, device_id: str, track_id: str, event_data: Dict):
        """è½¬å‘å®Œæˆäº‹ä»¶åˆ°Javaåç«¯"""
        try:
            # æ„å»ºè½¬å‘æ•°æ®
            completion_data = {
                "device_id": device_id,
                "track_id": track_id,
                "event_type": "speak_done",
                "event_data": event_data,
                "process_info": self.pending_requests.get(track_id, {}),
                "timestamp": datetime.now().isoformat()
            }
            
            # å‘é€åˆ°Java API
            java_api_url = self.config.get("manager-api", {}).get("url", "http://localhost:8080")
            completion_endpoint = f"{java_api_url}/api/device/completion"
            
            self.logger.bind(tag=TAG).info(f"ğŸ“¤ è½¬å‘å®Œæˆäº‹ä»¶åˆ°Java: {completion_endpoint}")
            
            # è¿™é‡Œåº”è¯¥ä½¿ç”¨HTTPå®¢æˆ·ç«¯å‘é€POSTè¯·æ±‚
            # import aiohttp
            # async with aiohttp.ClientSession() as session:
            #     async with session.post(completion_endpoint, json=completion_data) as response:
            #         if response.status == 200:
            #             self.logger.bind(tag=TAG).info("âœ… Javaè½¬å‘æˆåŠŸ")
            
            # æ¨¡æ‹ŸHTTPè¯·æ±‚
            await asyncio.sleep(0.2)
            self.logger.bind(tag=TAG).info(f"âœ… å®Œæˆäº‹ä»¶è½¬å‘æˆåŠŸ: {track_id}")
            
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"è½¬å‘åˆ°Javaå¤±è´¥: {e}")
    
    def get_request_status(self, track_id: str) -> Dict:
        """è·å–è¯·æ±‚å¤„ç†çŠ¶æ€"""
        return self.pending_requests.get(track_id, {})
    
    def get_all_pending_requests(self) -> Dict:
        """è·å–æ‰€æœ‰å¾…å¤„ç†è¯·æ±‚"""
        return self.pending_requests.copy()
    
    async def cleanup_old_requests(self, max_age_hours: int = 24):
        """æ¸…ç†æ—§çš„è¯·æ±‚è®°å½•"""
        now = datetime.now()
        to_remove = []
        
        for track_id, request_info in self.pending_requests.items():
            register_time_str = request_info.get("register_time", "")
            if register_time_str:
                try:
                    register_time = datetime.fromisoformat(register_time_str)
                    age = now - register_time
                    
                    if age.total_seconds() > max_age_hours * 3600:
                        to_remove.append(track_id)
                        
                except ValueError:
                    # æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œä¹Ÿåˆ é™¤
                    to_remove.append(track_id)
        
        for track_id in to_remove:
            del self.pending_requests[track_id]
        
        if to_remove:
            self.logger.bind(tag=TAG).info(f"ğŸ—‘ï¸ æ¸…ç†äº† {len(to_remove)} ä¸ªæ—§è¯·æ±‚è®°å½•")


class AwakenWithCallbackService:
    """å¸¦å›è°ƒçš„å”¤é†’æœåŠ¡ - é›†æˆäº†å®Œæ•´çš„Webhooksæµç¨‹"""
    
    def __init__(self, config: Dict[str, Any], mqtt_client, tts_provider=None):
        self.config = config
        self.mqtt_client = mqtt_client
        self.callback_handler = WebhookCallbackHandler(config, mqtt_client, tts_provider)
        self.logger = setup_logging()
    
    async def send_awaken_with_callback(self, device_id: str, message: str, message_type: str = "weather") -> str:
        """
        å‘é€å”¤é†’æ¶ˆæ¯å¹¶å¯åŠ¨å®Œæ•´çš„å›è°ƒæµç¨‹
        
        è¿™æ˜¯ç”¨æˆ·åº”è¯¥è°ƒç”¨çš„ä¸»è¦æ–¹æ³•ï¼Œå®ƒä¼šè‡ªåŠ¨å¤„ç†æ•´ä¸ªæµç¨‹ï¼š
        1. æ³¨å†Œå›è°ƒè¯·æ±‚
        2. å‘é€MQTTå”¤é†’å‘½ä»¤
        3. ç­‰å¾…è®¾å¤‡ACK
        4. è‡ªåŠ¨ç”ŸæˆTTS
        5. å‘é€éŸ³é¢‘åˆ°è®¾å¤‡
        6. å¤„ç†æ’­æ”¾å®Œæˆäº‹ä»¶
        """
        try:
            # 1. ç”Ÿæˆtrack_idå¹¶æ³¨å†Œå›è°ƒè¯·æ±‚
            track_id = await self.callback_handler.register_awaken_request(device_id, message)
            
            # 2. å‘é€MQTTå”¤é†’å‘½ä»¤
            await self.mqtt_client.send_awaken_command(device_id, message, message_type)
            
            self.logger.bind(tag=TAG).info(f"ğŸš€ å¯åŠ¨å®Œæ•´å›è°ƒæµç¨‹: {device_id}, track_id: {track_id}")
            
            return track_id
            
        except Exception as e:
            self.logger.bind(tag=TAG).error(f"âŒ å¯åŠ¨å›è°ƒæµç¨‹å¤±è´¥: {e}")
            raise
    
    def get_flow_status(self, track_id: str) -> Dict:
        """è·å–å®Œæ•´æµç¨‹çš„çŠ¶æ€"""
        return self.callback_handler.get_request_status(track_id)
