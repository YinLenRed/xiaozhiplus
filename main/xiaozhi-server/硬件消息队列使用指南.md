# 🎙️ 硬件消息队列使用指南

## 📋 功能概述

硬件消息队列管理器确保设备按顺序完整播放每条消息，不会被新消息打断。无论Java后端推送多少条消息，硬件都会：

1. **按优先级排序** - 预警消息优先播放
2. **顺序播放** - 每条消息播放完毕后再播放下一条
3. **不被打断** - 正在播放的消息不会被新消息中断
4. **自动重试** - 播放失败时自动重试

## 🏗️ 系统架构

```
Java后端 → MQTT → Python服务 → 消息队列 → 硬件设备
                    ↓
              UnifiedEventService
                    ↓
             MessageQueueManager
                    ↓
            按优先级排队 → 逐一播放
```

## ✅ 已实现功能

### 🎵 消息队列管理
- **队列机制**: 每个设备独立的消息队列
- **优先级排序**: 高优先级消息优先播放
- **顺序播放**: 严格按顺序一条条播放
- **状态跟踪**: 实时跟踪每条消息的播放状态

### 🔄 播放控制
- **播放完成检测**: 监听`EVT_SPEAK_DONE`事件
- **自动触发下一条**: 当前消息播放完成后自动播放下一条
- **错误处理**: 播放失败时自动标记并继续下一条
- **超时机制**: 防止队列卡死

### ⚡ 优先级系统
| 优先级 | 类型 | 示例 |
|--------|------|------|
| 0 | 紧急预警 | 天气预警、安全警报 |
| 1 | 重要消息 | 节假日问候、节气提醒 |
| 2 | 普通消息 | 天气播报、日常提醒 |
| 3 | 低优先级 | 其他信息 |

## 🚀 使用方法

### 1. 自动集成（推荐）

消息队列已自动集成到`UnifiedEventService`中，Java后端推送的所有消息都会自动进入队列：

```python
# Java后端MQTT推送 → 自动进入队列 → 按顺序播放
# 无需修改现有代码，完全向后兼容
```

### 2. 直接使用队列API

```python
from core.queue.message_queue_manager import MessageQueueManager

# 创建队列管理器
queue_manager = MessageQueueManager(unified_event_service)

# 添加消息到队列
message_id = queue_manager.add_message(
    device_id="f0:9e:9e:04:8a:44",
    content="这是一条测试消息",
    category="system_reminder",
    priority=1,
    user_info={"source": "manual"}
)

# 查看队列状态
status = queue_manager.get_device_queue_status("f0:9e:9e:04:8a:44")
print(status)
```

### 3. Java后端使用（无需更改）

Java后端继续使用原有的MQTT推送方式，消息会自动进入队列：

```json
{
  "device_id": "f0:9e:9e:04:8a:44",
  "title": "天气预警",
  "data": "大风蓝色预警",
  "prompt": "有大风预警，请注意安全"
}
```

## 🧪 测试验证

### 快速测试单条消息
```bash
python 测试消息队列.py single
```

### 测试快速多条消息（验证队列功能）
```bash
python 测试消息队列.py rapid
```

### 测试优先级排序
```bash
python 测试消息队列.py priority
```

### 交互式测试
```bash
python 测试消息队列.py
```

## 📊 队列状态监控

### 查看设备队列状态
```python
status = queue_manager.get_device_queue_status("device_id")
```

**返回信息**：
```json
{
  "device_id": "f0:9e:9e:04:8a:44",
  "queue_length": 3,
  "is_playing": true,
  "current_message": {
    "message_id": "MSG_1693234567_abc123",
    "content": "正在播放的消息...",
    "status": "playing",
    "track_id": "QUEUE_1693234567_def456"
  },
  "total_messages": 10,
  "completed_messages": 7,
  "failed_messages": 0,
  "pending_messages": [...]
}
```

### 查看所有队列状态
```python
all_status = queue_manager.get_all_queues_status()
```

## 🔧 配置选项

### 队列配置（在MessageQueueManager中）
```python
# 队列大小限制
max_queue_size = 50  # 每设备最大队列长度

# 超时设置
message_timeout = 60  # 消息播放超时时间（秒）

# 重试机制
max_retries = 3  # 最大重试次数
```

### 优先级配置
```python
# 在_send_event_to_device方法中
priority = 0 if event_type == "weather_alert" else 1
```

## 🎯 实际效果

### 场景1：Java连续推送多条消息
```
时间轴：
00:00 - Java推送天气预警 （优先级0）
00:01 - Java推送节日问候 （优先级1）  
00:02 - Java推送天气播报 （优先级2）

硬件播放顺序：
1. 天气预警（立即播放）
2. 节日问候（等天气预警播放完）
3. 天气播报（等节日问候播放完）
```

### 场景2：正在播放时收到高优先级消息
```
时间轴：
00:00 - 开始播放普通消息A
00:05 - Java推送紧急预警（优先级0）
00:10 - 消息A播放完成

播放顺序：
1. 继续播放消息A（不中断）
2. 紧急预警（插队到队列最前面）
3. 其他排队消息...
```

## 🆚 对比传统方式

| 方面 | 传统方式 | 消息队列方式 |
|------|----------|--------------|
| **消息打断** | 新消息会打断当前播放 | 永不打断，按顺序播放 |
| **优先级** | 无优先级概念 | 智能优先级排序 |
| **丢失风险** | 可能丢失被打断的消息 | 所有消息都会播放 |
| **用户体验** | 断断续续，体验差 | 流畅连贯，体验好 |
| **状态追踪** | 难以追踪播放状态 | 完整的状态追踪 |

## 🔍 故障排除

### 1. 队列卡死
**现象**: 硬件不播放消息，队列有积压
**解决**: 
```python
# 清空设备队列
queue_manager.clear_device_queue("device_id")
```

### 2. 消息播放失败
**现象**: 消息状态显示为`failed`
**排查**:
1. 检查硬件连接
2. 查看TTS服务状态
3. 检查WebSocket连接

### 3. 优先级不生效
**现象**: 高优先级消息没有优先播放
**原因**: 可能已有消息在播放中
**说明**: 队列只对等待中的消息排序，不会中断正在播放的消息

## 📈 性能监控

### 关键指标
- 队列长度：正常 < 10条
- 播放成功率：应 > 95%
- 平均等待时间：取决于消息长度
- 内存使用：每条消息约 1KB

### 监控命令
```python
# 获取统计信息
stats = queue_manager.get_all_queues_status()
print(f"总处理消息: {stats['total_messages_processed']}")
print(f"运行时间: {stats['uptime_seconds']}秒")
```

## 🎉 总结

消息队列功能已完全集成到系统中，为用户提供：

✅ **完整播放** - 每条消息都能完整播放，不被打断  
✅ **智能排序** - 重要消息优先播放  
✅ **流畅体验** - 顺序播放，体验连贯  
✅ **向后兼容** - 现有Java代码无需修改  
✅ **状态透明** - 完整的播放状态追踪  

无论Java后端推送多少条消息，硬件都会按优先级和顺序依次播放，确保用户获得最佳的语音交互体验！ 🎙️✨
